
/**
 * In this assignment I used various stages to determine how I would complete the assignment in the most efficient way.
 * The first stage is to specify the assignment's goals, guidelines, and mechanisms. This involves figuring out how consumers will type their five-character password within their allotted number of tries,
 * how the code behaves, how a unique set of characters must be used, how those characters are assessed to determine if they meet the guidelines, and so on. 
 * Java is used to implement the structure and logic of the Cyber security system using object-oriented programming techniques.
 * Ensuring each class implemented its own specific objective in this project was a challenge that I had faced as some of the classes were more complex then expected.
 * The ExtendedLetter class was the final class that was created and was a very crucial part of the project as it initialized variables and insured completion of the code.
 * 
 */
public class WordLL {
		//Initializing an empty history
		//Setting the mysteryWord attribute to the parameter mystery
	    private Word mysteryWord;
	    private LinearNode<Word> history;
	    
	    public WordLL(Word mystery){
	        history = null;
	        this.mysteryWord = mystery;
	    }
	    /**
	     * uses a Word as a test argument for the mystery word in this game. 
	     * Returns true if the word represented by guess is the same as the word represented by mysteryWord, 
	     * otherwise returns false. • updates the label of all the letters contained within Word guess
	     * using labelWord) and moves Word guess to the front of history (you must create a node of the class LinearNode, 
	     * store the Word guess object in it, and then link this node to the front of the linked list pointed by history).
	     * @param guess
	     * @return
	     */

	    public boolean tryWord(Word guess) {

	        // Labeling the letters of the guess word that was inputed
	        boolean result = guess.labelWord(mysteryWord);

	        if (history == null) {
	            history = new LinearNode<>(guess);
	        } else {
	   
	            LinearNode<Word> headNode = new LinearNode<>(guess);
	            headNode.setNext(history);
	            history = headNode;
	        }

	        return result;
	    }
	    /**
	     *  Generates a String representation of the previous guesses, starting with the most recent estimate.
	     *  Examples of the strings generated by this method toString() after each estimate are shown in the Introduction.
	     *  As in the preceding example in this document, following the third guess
	     */
	    
		@Override
	    public String toString() {
	        StringBuilder builder = new StringBuilder();

	        LinearNode<Word> current = history;
	        while (current != null) {
	        	// End of line '\n' after each word
	            builder.append("Word: ").append(current.getElement().toString()).append("\n");
	            current = current.getNext();
	        }

	        return builder.toString();
	    }
		}
	    
